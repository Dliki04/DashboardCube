import { SaveCancelFn } from '../driver/utils';
import { Query, QueryCache, QueryWithParams } from './QueryCache';
import { DriverFactory, DriverFactoryByDataSource } from './DriverFactory';
import { DownloadTableData, StreamOptions, UnloadOptions } from '../driver';
import { QueryQueue } from './QueryQueue';
import { DriverInterface } from '../driver/driver.interface';
export declare function getLastUpdatedAtTimestamp(timestamps: (number | undefined)[]): number | undefined;
declare type VersionEntry = {
    table_name: string;
    content_version: string;
    structure_version: string;
    last_updated_at: number;
    naming_version?: number;
};
declare type QueryDateRange = [string, string];
declare type IndexDescription = {
    sql: QueryWithParams;
    indexName: string;
};
export declare type PreAggregationDescription = {
    preAggregationsSchema: string;
    type: 'rollup' | 'originalSql';
    preAggregationId: string;
    priority: number;
    dataSource: string;
    external: boolean;
    previewSql: QueryWithParams;
    timezone: string;
    indexesSql: IndexDescription[];
    invalidateKeyQueries: QueryWithParams[];
    sql: QueryWithParams;
    loadSql: QueryWithParams;
    tableName: string;
    matchedTimeDimensionDateRange: QueryDateRange;
    granularity: string;
    partitionGranularity: string;
    preAggregationStartEndQueries: [QueryWithParams, QueryWithParams];
    timestampFormat: string;
    expandedPartition: boolean;
};
declare type LoadPreAggregationResult = {
    targetTableName: string;
    refreshKeyValues: any[];
    lastUpdatedAt: number;
};
export declare class PreAggregationLoader {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    private preAggregations;
    private preAggregation;
    private preAggregationsTablesToTempTables;
    private loadCache;
    private waitForRenew;
    private forceBuild;
    private orphanedTimeout;
    private externalDriverFactory;
    private requestId;
    private metadata;
    private structureVersionPersistTime;
    private externalRefresh;
    constructor(redisPrefix: string, driverFactory: DriverFactory, logger: any, queryCache: QueryCache, preAggregations: PreAggregations, preAggregation: any, preAggregationsTablesToTempTables: any, loadCache: any, options?: any);
    loadPreAggregation(): Promise<LoadPreAggregationResult>;
    protected loadPreAggregationWithKeys(): Promise<LoadPreAggregationResult>;
    protected contentVersion(invalidationKeys: any): string;
    protected priority(defaultValue: any): any;
    protected getInvalidationKeyValues(): Promise<[unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown]>;
    protected scheduleRefresh(invalidationKeys: any, newVersionEntry: any): void;
    protected executeInQueue(invalidationKeys: any, priority: any, newVersionEntry: any): Promise<any>;
    protected preAggregationQueryKey(invalidationKeys: any): any[];
    protected targetTableName(versionEntry: any): string;
    refresh(preAggregation: any, newVersionEntry: any, invalidationKeys: any): (client: any) => any;
    protected logExecutingSql(payload: any): void;
    protected queryOptions(invalidationKeys: any, query: any, params: any, targetTableName: any, newVersionEntry: any): {
        queryKey: any[];
        query: any;
        values: any;
        targetTableName: any;
        requestId: string;
        newVersionEntry: any;
    };
    protected refreshImplStoreInSourceStrategy(client: DriverInterface, newVersionEntry: any, saveCancelFn: SaveCancelFn, preAggregation: any, invalidationKeys: any): Promise<void>;
    /**
     * Strategy to copy pre-aggregation from source db (with write permissions) to external data
     */
    protected refreshImplTempTableExternalStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, preAggregation: any, invalidationKeys: any): Promise<void>;
    /**
     * Strategy to copy pre-aggregation from source db (for read-only permissions) to external data
     */
    protected refreshImplStreamExternalStrategy(client: DriverInterface, newVersionEntry: VersionEntry, saveCancelFn: any, preAggregation: any, invalidationKeys: any): Promise<void>;
    protected getUnloadOptions(): UnloadOptions;
    protected getStreamingOptions(): StreamOptions;
    /**
     * Create table (for db with write permissions) and extract data via memory/stream/unload
     */
    protected downloadTempExternalPreAggregation(client: DriverInterface, newVersionEntry: any, preAggregation: any, saveCancelFn: SaveCancelFn, queryOptions: any): Promise<DownloadTableData>;
    protected uploadExternalPreAggregation(tableData: DownloadTableData, newVersionEntry: VersionEntry, saveCancelFn: SaveCancelFn, queryOptions: any): Promise<void>;
    protected createIndexes(driver: any, newVersionEntry: any, saveCancelFn: any, queryOptions: any): Promise<void>;
    protected prepareIndexesSql(newVersionEntry: any, queryOptions: any): any;
    protected dropOrphanedTables(client: DriverInterface, justCreatedTable: string, saveCancelFn: SaveCancelFn, external: boolean, queryOptions: any): Promise<boolean>;
}
export declare class PreAggregationPartitionRangeLoader {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    private readonly preAggregations;
    private readonly preAggregation;
    private readonly preAggregationsTablesToTempTables;
    private readonly loadCache;
    private readonly options;
    protected waitForRenew: boolean;
    protected requestId: string;
    protected dataSource: string;
    constructor(redisPrefix: string, driverFactory: DriverFactory, logger: any, queryCache: QueryCache, preAggregations: PreAggregations, preAggregation: PreAggregationDescription, preAggregationsTablesToTempTables: any, loadCache: any, options?: any);
    private loadRangeQuery;
    protected getInvalidationKeyValues(range: any): Promise<any[]>;
    protected priority(defaultValue: any): any;
    replaceQueryBuildRangeParams(queryValues: string[]): Promise<string[] | null>;
    private replacePartitionSqlAndParams;
    private partitionPreAggregationDescription;
    loadPreAggregations(): Promise<LoadPreAggregationResult>;
    partitionPreAggregations(): Promise<PreAggregationDescription[]>;
    private partitionRanges;
    loadBuildRange(): Promise<QueryDateRange>;
    private orNowIfEmpty;
    private static checkDataRangeType;
    static intersectDateRanges(rangeA: QueryDateRange | null, rangeB: QueryDateRange | null): QueryDateRange;
    static timeSeries(granularity: string, dateRange: QueryDateRange): QueryDateRange[];
    static partitionTableName(tableName: string, partitionGranularity: string, dateRange: string[]): string;
    static inDbTimeZone(preAggregationDescription: any, timestamp: string): string;
    static extractDate(data: any): string;
    static FROM_PARTITION_RANGE: string;
    static TO_PARTITION_RANGE: string;
}
declare type PreAggregationsOptions = {
    preAggregationsSchemaCacheExpire?: number;
    loadCacheQueueOptions?: any;
    queueOptions?: (dataSource: string) => Promise<{
        concurrency: number;
        continueWaitTimeout?: number;
        executionTimeout?: number;
        orphanedTimeout?: number;
        heartBeatInterval?: number;
    }>;
    redisPool?: any;
    continueWaitTimeout?: number;
    cacheAndQueueDriver?: 'redis' | 'memory';
    skipExternalCacheAndQueue?: boolean;
};
export declare class PreAggregations {
    private readonly redisPrefix;
    private readonly driverFactory;
    private readonly logger;
    private readonly queryCache;
    options: PreAggregationsOptions;
    private cacheDriver;
    externalDriverFactory: any;
    structureVersionPersistTime: any;
    private readonly usedTablePersistTime;
    private readonly externalRefresh;
    private readonly loadCacheQueue;
    private readonly queue;
    private readonly getQueueEventsBus;
    constructor(redisPrefix: string, driverFactory: DriverFactoryByDataSource, logger: any, queryCache: QueryCache, options: any);
    protected tablesUsedRedisKey(tableName: any): string;
    addTableUsed(tableName: any): Promise<{
        key: string;
        bytes: number;
    }>;
    tablesUsed(): Promise<any[]>;
    loadAllPreAggregationsIfNeeded(queryBody: any): any;
    checkPartitionsBuildRangeCache(queryBody: any): Promise<[unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown]>;
    expandPartitionsInPreAggregations(queryBody: Query): Promise<Query>;
    getQueue(dataSource?: string): Promise<QueryQueue>;
    /**
     * Returns registered queries queues hash table.
     */
    getQueues(): {
        [dataSource: string]: QueryQueue;
    };
    getLoadCacheQueue(dataSource?: string): QueryQueue;
    static preAggregationQueryCacheKey(preAggregation: any): any;
    static targetTableName(versionEntry: any): string;
    static structureVersion(preAggregation: any): string;
    getVersionEntries(preAggregations: PreAggregationDescription[], requestId: any): Promise<VersionEntry[][]>;
    getQueueState(dataSource: string): Promise<any[]>;
    cancelQueriesFromQueue(queryKeys: string[], dataSource: string): Promise<boolean[]>;
}
export {};
//# sourceMappingURL=PreAggregations.d.ts.map