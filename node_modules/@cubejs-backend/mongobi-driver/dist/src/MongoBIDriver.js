"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MongoBIDriver = void 0;
const mysql2_1 = require("mysql2");
const generic_pool_1 = __importDefault(require("generic-pool"));
const query_orchestrator_1 = require("@cubejs-backend/query-orchestrator");
const MySQLType_1 = require("./MySQLType");
class MongoBIDriver extends query_orchestrator_1.BaseDriver {
    constructor(config = {}) {
        super();
        this.config = {
            host: process.env.CUBEJS_DB_HOST,
            database: process.env.CUBEJS_DB_NAME,
            port: process.env.CUBEJS_DB_PORT,
            user: process.env.CUBEJS_DB_USER,
            password: process.env.CUBEJS_DB_PASS,
            ssl: this.getSslOptions(),
            authPlugins: {
                mysql_clear_password: () => async () => {
                    const password = config.password || process.env.CUBEJS_DB_PASS || '';
                    return Buffer.from((password).concat('\0')).toString();
                }
            },
            typeCast: (field, next) => {
                if (field.type === 'DATETIME') {
                    // Example value 1998-08-02 00:00:00
                    // Here we just omit Date parsing and avoiding Date.toString() done by driver. MongoBI original format is just fine.
                    return field.string();
                }
                return next();
            },
            ...config
        };
        this.pool = generic_pool_1.default.createPool({
            create: async () => {
                const conn = mysql2_1.createConnection(this.config);
                if (conn.on) {
                    conn.on('error', () => {
                        conn.destroy();
                    });
                }
                await conn.promise().connect();
                return conn;
            },
            destroy: async (connection) => connection.promise().end(),
            validate: async (connection) => {
                try {
                    await connection.promise().query({
                        sql: 'SELECT 1',
                    });
                }
                catch (e) {
                    this.databasePoolError(e);
                    return false;
                }
                return true;
            }
        }, {
            min: 0,
            max: this.config.maxPoolSize || 8,
            evictionRunIntervalMillis: 10000,
            softIdleTimeoutMillis: 30000,
            idleTimeoutMillis: 30000,
            testOnBorrow: true,
            acquireTimeoutMillis: 20000
        });
    }
    /**
     * Returns default concurrency value.
     */
    static getDefaultConcurrency() {
        return 2;
    }
    withConnection(fn) {
        const self = this;
        const connectionPromise = this.pool.acquire();
        let cancelled = false;
        const cancelObj = {};
        const promise = connectionPromise.then(conn => {
            cancelObj.cancel = async () => {
                cancelled = true;
                await self.withConnection(async (processConnection) => {
                    const processRows = await processConnection.promise().query({
                        sql: 'SHOW PROCESSLIST'
                    });
                    await Promise.all(processRows.filter((row) => row.Time >= 599)
                        .map((row) => processConnection.promise().query({
                        sql: `KILL ${row.Id}`
                    })));
                });
            };
            return fn(conn)
                .then(res => this.pool.release(conn).then(() => {
                if (cancelled) {
                    throw new Error('Query cancelled');
                }
                return res;
            }))
                .catch((err) => this.pool.release(conn).then(() => {
                if (cancelled) {
                    throw new Error('Query cancelled');
                }
                throw err;
            }));
        });
        promise.cancel = () => cancelObj.cancel();
        return promise;
    }
    async testConnection() {
        // eslint-disable-next-line no-underscore-dangle
        const conn = await this.pool._factory.create();
        try {
            await conn.promise().query('SELECT 1', []);
        }
        finally {
            // eslint-disable-next-line no-underscore-dangle
            await this.pool._factory.destroy(conn);
        }
    }
    async query(sql, values) {
        return this.withConnection(async (conn) => {
            await this.prepareConnection(conn);
            const [rows] = await conn.promise().query({
                sql,
                values,
            });
            return rows;
        });
    }
    async prepareConnection(conn) {
        await conn.promise().query({
            sql: `SET time_zone = '${this.config.storeTimezone || '+00:00'}'`,
            values: [],
        });
    }
    async stream(query, values, options) {
        // eslint-disable-next-line no-underscore-dangle
        const conn = await this.pool._factory.create();
        try {
            await this.prepareConnection(conn);
            const [rowStream, fields] = await (new Promise((resolve, reject) => {
                const stream = conn.query(query, values).stream(options);
                stream.on('fields', (f) => {
                    resolve([stream, f]);
                });
                stream.on('error', (e) => {
                    reject(e);
                });
            }));
            return {
                rowStream,
                types: fields.map((field) => ({
                    name: field.name,
                    type: this.toGenericType(MySQLType_1.getNativeTypeName(field.columnType)),
                })),
                release: async () => {
                    // eslint-disable-next-line no-underscore-dangle
                    await this.pool._factory.destroy(conn);
                }
            };
        }
        catch (e) {
            // eslint-disable-next-line no-underscore-dangle
            await this.pool._factory.destroy(conn);
            throw e;
        }
    }
    async downloadQueryResults(query, values, options) {
        if ((options || {}).streamImport) {
            return this.stream(query, values, options);
        }
        return this.withConnection(async (conn) => {
            await this.prepareConnection(conn);
            const [rows, fields] = await conn.promise().query(query, values);
            return {
                rows,
                types: fields.map((field) => ({
                    name: field.name,
                    type: this.toGenericType(MySQLType_1.getNativeTypeName(field.columnType)),
                })),
            };
        });
    }
    async release() {
        await this.pool.drain();
        await this.pool.clear();
    }
    informationSchemaQuery() {
        if (this.config.database) {
            return `${super.informationSchemaQuery()} AND columns.table_schema = '${this.config.database}'`;
        }
        else {
            return super.informationSchemaQuery();
        }
    }
    quoteIdentifier(identifier) {
        return `\`${identifier}\``;
    }
    readOnly() {
        // Mongo BI doesn't support table creation
        return true;
    }
}
exports.MongoBIDriver = MongoBIDriver;
//# sourceMappingURL=MongoBIDriver.js.map