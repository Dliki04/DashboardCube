import type { Application as ExpressApplication, ErrorRequestHandler, RequestHandler, Response } from 'express';
import { QueryType } from './types/strings';
import { RequestContext, ExtendedRequestContext, Request, QueryRewriteFn, SecurityContextExtractorFn, ExtendContextFn, ResponseResultFn, QueryRequest } from './types/request';
import { CheckAuthInternalOptions, JWTOptions, CheckAuthFn } from './types/auth';
import { Query, NormalizedQuery } from './types/query';
import { UserBackgroundContext, ApiGatewayOptions } from './types/gateway';
import { CheckAuthMiddlewareFn, RequestLoggerMiddlewareFn } from './interfaces';
import { SubscriptionServer, WebSocketSendMessageFn } from './SubscriptionServer';
import { SQLServer } from './sql-server';
/**
 * API gateway server class.
 */
declare class ApiGateway {
    protected readonly apiSecret: string;
    protected readonly compilerApi: any;
    protected readonly adapterApi: any;
    protected readonly logger: any;
    protected readonly options: ApiGatewayOptions;
    protected readonly refreshScheduler: any;
    protected readonly scheduledRefreshContexts: ApiGatewayOptions['scheduledRefreshContexts'];
    protected readonly scheduledRefreshTimeZones: ApiGatewayOptions['scheduledRefreshTimeZones'];
    protected readonly basePath: string;
    protected readonly queryRewrite: QueryRewriteFn;
    protected readonly subscriptionStore: any;
    protected readonly enforceSecurityChecks: boolean;
    protected readonly standalone: boolean;
    protected readonly extendContext?: ExtendContextFn;
    protected readonly dataSourceStorage: any;
    readonly checkAuthFn: CheckAuthFn;
    readonly checkAuthSystemFn: CheckAuthFn;
    protected readonly checkAuthMiddleware: CheckAuthMiddlewareFn;
    protected readonly requestLoggerMiddleware: RequestLoggerMiddlewareFn;
    protected readonly securityContextExtractor: SecurityContextExtractorFn;
    protected readonly releaseListeners: (() => any)[];
    protected readonly playgroundAuthSecret?: string;
    constructor(apiSecret: string, compilerApi: any, adapterApi: any, logger: any, options: ApiGatewayOptions);
    initApp(app: ExpressApplication): void;
    initSQLServer(): SQLServer;
    initSubscriptionServer(sendMessage: WebSocketSendMessageFn): SubscriptionServer;
    protected duration(requestStarted: any): any;
    runScheduledRefresh({ context, res, queryingOptions }: {
        context: RequestContext;
        res: ResponseResultFn;
        queryingOptions: any;
    }): Promise<void>;
    meta({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    metaExtended({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregations({ cacheOnly, context, res }: {
        cacheOnly?: boolean;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPartitions({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPreview({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    buildPreAggregations({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationsInQueue({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    cancelPreAggregationsFromQueue({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    /**
     * Convert incoming query parameter (JSON fetched from the HTTP) to
     * an array of query type and array of normalized queries.
     */
    protected getNormalizedQueries(query: Record<string, any> | Record<string, any>[], context: RequestContext): Promise<[QueryType, NormalizedQuery[]]>;
    sql({ query, context, res }: QueryRequest): Promise<void>;
    protected createSecurityContextExtractor(options?: JWTOptions): SecurityContextExtractorFn;
    protected coerceForSqlQuery(query: any, context: Readonly<RequestContext>): any;
    protected dryRun({ query, context, res }: QueryRequest): Promise<void>;
    /**
     * Returns an array of sqlQuery objects for specified normalized
     * queries.
     * @internal
     */
    private getSqlQueriesInternal;
    /**
     * Execute query and return adapter's result.
     * @internal
     */
    private getSqlResponseInternal;
    /**
     * Convert adapter's result and other request paramters to a final
     * result object.
     * @internal
     */
    private getResultInternal;
    /**
     * Data queries APIs (`/load`, `/subscribe`) entry point. Used by
     * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the
     * data.
     */
    load(request: QueryRequest): Promise<void>;
    subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }: {
        context: any;
        signedWithPlaygroundAuthSecret: any;
        connectionId: any;
        res: any;
    }): any;
    unSubscribeQueueEvents({ context, connectionId }: {
        context: any;
        connectionId: any;
    }): any;
    subscribe({ query, context, res, subscribe, subscriptionState, queryType, apiType }: {
        query: any;
        context: any;
        res: any;
        subscribe: any;
        subscriptionState: any;
        queryType: any;
        apiType: any;
    }): Promise<void>;
    protected resToResultFn(res: Response): (message: any, { status }?: {
        status?: number | undefined;
    }) => Response<any, Record<string, any>>;
    protected parseQueryParam(query: any): Query | Query[];
    protected getCompilerApi(context: any): any;
    protected getAdapterApi(context: any): any;
    contextByReq(req: Request, securityContext: any, requestId: string): Promise<ExtendedRequestContext>;
    protected handleErrorMiddleware: ErrorRequestHandler;
    handleError({ e, context, query, res, requestStarted }: any): void;
    protected wrapCheckAuthMiddleware(fn: CheckAuthMiddlewareFn): CheckAuthMiddlewareFn;
    protected wrapCheckAuth(fn: CheckAuthFn): CheckAuthFn;
    protected createDefaultCheckAuth(options?: JWTOptions, internalOptions?: CheckAuthInternalOptions): CheckAuthFn;
    protected createCheckAuthFn(options: ApiGatewayOptions): CheckAuthFn;
    protected createCheckAuthSystemFn(): CheckAuthFn;
    protected extractAuthorizationHeaderWithSchema(req: Request): string | undefined;
    protected checkAuthWrapper(checkAuthFn: CheckAuthFn, req: Request, res: Response, next: any): Promise<void>;
    protected checkAuth: RequestHandler;
    protected checkAuthSystemMiddleware: RequestHandler;
    protected requestContextMiddleware: RequestHandler;
    protected requestLogger: RequestHandler;
    protected logNetworkUsage: RequestHandler;
    protected compareDateRangeTransformer(query: any): any;
    log(event: {
        type: string;
        [key: string]: any;
    }, context?: Partial<RequestContext>): void;
    protected healthResponse(res: Response, health: 'HEALTH' | 'DOWN'): void;
    protected createSystemContextHandler: (basePath: string) => RequestHandler;
    protected readiness: RequestHandler;
    protected liveness: RequestHandler;
    release(): void;
}
export { UserBackgroundContext, ApiGatewayOptions, ApiGateway, };
//# sourceMappingURL=gateway.d.ts.map