"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApiGateway = void 0;
/* eslint-disable no-restricted-syntax */
const jsonwebtoken_1 = __importDefault(require("jsonwebtoken"));
const ramda_1 = __importDefault(require("ramda"));
const body_parser_1 = __importDefault(require("body-parser"));
const express_graphql_1 = require("express-graphql");
const structured_clone_1 = __importDefault(require("@ungap/structured-clone"));
const shared_1 = require("@cubejs-backend/shared");
const enums_1 = require("./types/enums");
const requestParser_1 = require("./requestParser");
const UserError_1 = require("./UserError");
const CubejsHandlerError_1 = require("./CubejsHandlerError");
const SubscriptionServer_1 = require("./SubscriptionServer");
const LocalSubscriptionStore_1 = require("./LocalSubscriptionStore");
const query_1 = require("./query");
const cached_handler_1 = require("./cached-handler");
const jwk_1 = require("./jwk");
const sql_server_1 = require("./sql-server");
const graphql_1 = require("./graphql");
const prepareAnnotation_1 = require("./helpers/prepareAnnotation");
const transformData_1 = __importDefault(require("./helpers/transformData"));
const transformMetaExtended_1 = require("./helpers/transformMetaExtended");
/**
 * API gateway server class.
 */
class ApiGateway {
    constructor(apiSecret, compilerApi, adapterApi, logger, options) {
        this.apiSecret = apiSecret;
        this.compilerApi = compilerApi;
        this.adapterApi = adapterApi;
        this.logger = logger;
        this.options = options;
        this.releaseListeners = [];
        this.handleErrorMiddleware = async (e, req, res, next) => {
            this.handleError({
                e,
                context: req.context,
                res: this.resToResultFn(res),
                requestStarted: new Date(),
            });
            next(e);
        };
        this.checkAuth = async (req, res, next) => {
            await this.checkAuthWrapper(this.checkAuthFn, req, res, next);
        };
        this.checkAuthSystemMiddleware = async (req, res, next) => {
            await this.checkAuthWrapper(this.checkAuthSystemFn, req, res, next);
        };
        this.requestContextMiddleware = async (req, res, next) => {
            req.context = await this.contextByReq(req, req.securityContext, requestParser_1.getRequestIdFromRequest(req));
            if (next) {
                next();
            }
        };
        this.requestLogger = async (req, res, next) => {
            const details = requestParser_1.requestParser(req, res);
            this.log({ type: 'REST API Request', ...details }, req.context);
            if (next) {
                next();
            }
        };
        this.logNetworkUsage = async (req, res, next) => {
            this.log({
                type: 'Incoming network usage',
                service: 'api-http',
                bytes: Buffer.byteLength(req.url + req.rawHeaders.join('\n')) + (Number(req.get('content-length')) || 0),
                path: req.path,
            }, req.context);
            res.on('finish', () => {
                this.log({
                    type: 'Outgoing network usage',
                    service: 'api-http',
                    bytes: Number(res.get('content-length')) || 0,
                    path: req.path,
                }, req.context);
            });
            if (next) {
                next();
            }
        };
        this.createSystemContextHandler = (basePath) => {
            const body = {
                basePath,
                dockerVersion: shared_1.getEnv('dockerImageVersion') || null,
                serverCoreVersion: this.options.serverCoreVersion || null
            };
            return (req, res) => {
                res.status(200).json(body);
            };
        };
        this.readiness = async (req, res) => {
            let health = 'HEALTH';
            if (this.standalone) {
                const orchestratorApi = await this.adapterApi({});
                try {
                    // todo: test other data sources
                    orchestratorApi.addDataSeenSource('default');
                    await orchestratorApi.testConnection();
                }
                catch (e) {
                    this.log({
                        type: 'Internal Server Error on readiness probe',
                        error: e.stack || e.toString(),
                    });
                    return this.healthResponse(res, 'DOWN');
                }
                try {
                    await orchestratorApi.testOrchestratorConnections();
                }
                catch (e) {
                    this.log({
                        type: 'Internal Server Error on readiness probe',
                        error: e.stack || e.toString(),
                    });
                    health = 'DOWN';
                }
            }
            return this.healthResponse(res, health);
        };
        this.liveness = async (req, res) => {
            let health = 'HEALTH';
            try {
                await this.dataSourceStorage.testConnections();
            }
            catch (e) {
                this.log({
                    type: 'Internal Server Error on liveness probe',
                    error: e.stack || e.toString(),
                });
                return this.healthResponse(res, 'DOWN');
            }
            try {
                // @todo Optimize this moment?
                await this.dataSourceStorage.testOrchestratorConnections();
            }
            catch (e) {
                this.log({
                    type: 'Internal Server Error on liveness probe',
                    error: e.stack || e.toString(),
                });
                health = 'DOWN';
            }
            return this.healthResponse(res, health);
        };
        this.dataSourceStorage = options.dataSourceStorage;
        this.refreshScheduler = options.refreshScheduler;
        this.scheduledRefreshContexts = options.scheduledRefreshContexts;
        this.scheduledRefreshTimeZones = options.scheduledRefreshTimeZones;
        this.standalone = options.standalone;
        this.basePath = options.basePath;
        this.playgroundAuthSecret = options.playgroundAuthSecret;
        this.queryRewrite = options.queryRewrite || (async (query) => query);
        this.subscriptionStore = options.subscriptionStore || new LocalSubscriptionStore_1.LocalSubscriptionStore();
        this.enforceSecurityChecks = options.enforceSecurityChecks || (process.env.NODE_ENV === 'production');
        this.extendContext = options.extendContext;
        this.checkAuthFn = this.createCheckAuthFn(options);
        this.checkAuthSystemFn = this.createCheckAuthSystemFn();
        this.checkAuthMiddleware = options.checkAuthMiddleware
            ? this.wrapCheckAuthMiddleware(options.checkAuthMiddleware)
            : this.checkAuth;
        this.securityContextExtractor = this.createSecurityContextExtractor(options.jwt);
        this.requestLoggerMiddleware = options.requestLoggerMiddleware || this.requestLogger;
    }
    initApp(app) {
        const userMiddlewares = [
            this.checkAuthMiddleware,
            this.requestContextMiddleware,
            this.requestLoggerMiddleware
        ];
        // @todo Should we pass requestLoggerMiddleware?
        const guestMiddlewares = [];
        app.use(`${this.basePath}/graphql`, userMiddlewares, async (req, res) => {
            const compilerApi = this.getCompilerApi(req.context);
            let schema = compilerApi.getGraphQLSchema();
            if (!schema) {
                const metaConfig = await compilerApi.metaConfig({
                    requestId: req.context.requestId,
                });
                schema = graphql_1.makeSchema(metaConfig);
                compilerApi.setGraphQLSchema(schema);
            }
            return express_graphql_1.graphqlHTTP({
                schema,
                context: {
                    req,
                    apiGateway: this
                },
                graphiql: shared_1.getEnv('nodeEnv') !== 'production' ? { headerEditorEnabled: true } : false,
            })(req, res);
        });
        app.use(this.logNetworkUsage);
        app.get(`${this.basePath}/v1/load`, userMiddlewares, (async (req, res) => {
            await this.load({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.query.queryType,
            });
        }));
        const jsonParser = body_parser_1.default.json({ limit: '1mb' });
        app.post(`${this.basePath}/v1/load`, jsonParser, userMiddlewares, (async (req, res) => {
            await this.load({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.body.queryType
            });
        }));
        app.get(`${this.basePath}/v1/subscribe`, userMiddlewares, (async (req, res) => {
            await this.load({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res),
                queryType: req.query.queryType
            });
        }));
        app.get(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {
            await this.sql({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.post(`${this.basePath}/v1/sql`, userMiddlewares, (async (req, res) => {
            await this.sql({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.get(`${this.basePath}/v1/meta`, userMiddlewares, (async (req, res) => {
            if (req.query.hasOwnProperty('extended')) {
                await this.metaExtended({
                    context: req.context,
                    res: this.resToResultFn(res),
                });
            }
            else {
                await this.meta({
                    context: req.context,
                    res: this.resToResultFn(res),
                });
            }
        }));
        app.get(`${this.basePath}/v1/run-scheduled-refresh`, userMiddlewares, (async (req, res) => {
            await this.runScheduledRefresh({
                queryingOptions: req.query.queryingOptions,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.get(`${this.basePath}/v1/dry-run`, userMiddlewares, (async (req, res) => {
            await this.dryRun({
                query: req.query.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        app.post(`${this.basePath}/v1/dry-run`, jsonParser, userMiddlewares, (async (req, res) => {
            await this.dryRun({
                query: req.body.query,
                context: req.context,
                res: this.resToResultFn(res)
            });
        }));
        if (this.playgroundAuthSecret) {
            const systemMiddlewares = [
                this.checkAuthSystemMiddleware,
                this.requestContextMiddleware,
                this.requestLoggerMiddleware
            ];
            app.get('/cubejs-system/v1/context', systemMiddlewares, this.createSystemContextHandler(this.basePath));
            app.get('/cubejs-system/v1/pre-aggregations', systemMiddlewares, (async (req, res) => {
                await this.getPreAggregations({
                    cacheOnly: req.query.cacheOnly,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.get('/cubejs-system/v1/pre-aggregations/security-contexts', systemMiddlewares, (async (req, res) => {
                const contexts = this.scheduledRefreshContexts ? await this.scheduledRefreshContexts() : [];
                this.resToResultFn(res)({
                    securityContexts: contexts
                        .map(ctx => ctx && (ctx.securityContext || ctx.authInfo))
                        .filter(ctx => ctx)
                });
            }));
            app.get('/cubejs-system/v1/pre-aggregations/timezones', systemMiddlewares, (async (req, res) => {
                this.resToResultFn(res)({
                    timezones: this.scheduledRefreshTimeZones || []
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/partitions', jsonParser, systemMiddlewares, (async (req, res) => {
                await this.getPreAggregationPartitions({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/preview', jsonParser, systemMiddlewares, (async (req, res) => {
                await this.getPreAggregationPreview({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/build', jsonParser, systemMiddlewares, (async (req, res) => {
                await this.buildPreAggregations({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/queue', jsonParser, systemMiddlewares, (async (req, res) => {
                await this.getPreAggregationsInQueue({
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
            app.post('/cubejs-system/v1/pre-aggregations/cancel', jsonParser, systemMiddlewares, (async (req, res) => {
                await this.cancelPreAggregationsFromQueue({
                    query: req.body.query,
                    context: req.context,
                    res: this.resToResultFn(res)
                });
            }));
        }
        app.get('/readyz', guestMiddlewares, cached_handler_1.cachedHandler(this.readiness));
        app.get('/livez', guestMiddlewares, cached_handler_1.cachedHandler(this.liveness));
        app.post(`${this.basePath}/v1/pre-aggregations/can-use`, userMiddlewares, (req, res) => {
            const { transformedQuery, references } = req.body;
            const canUsePreAggregationForTransformedQuery = this.compilerApi(req.context)
                .canUsePreAggregationForTransformedQuery(transformedQuery, references);
            res.json({ canUsePreAggregationForTransformedQuery });
        });
        app.use(this.handleErrorMiddleware);
    }
    initSQLServer() {
        return new sql_server_1.SQLServer(this);
    }
    initSubscriptionServer(sendMessage) {
        return new SubscriptionServer_1.SubscriptionServer(this, sendMessage, this.subscriptionStore);
    }
    duration(requestStarted) {
        return requestStarted && (new Date().getTime() - requestStarted.getTime());
    }
    async runScheduledRefresh({ context, res, queryingOptions }) {
        const requestStarted = new Date();
        try {
            const refreshScheduler = this.refreshScheduler();
            res(await refreshScheduler.runScheduledRefresh(context, {
                ...this.parseQueryParam(queryingOptions || {}),
                throwErrors: true
            }));
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async meta({ context, res }) {
        const requestStarted = new Date();
        function visibilityFilter(item) {
            return shared_1.getEnv('devMode') || context.signedWithPlaygroundAuthSecret || item.isVisible;
        }
        try {
            const metaConfig = await this.getCompilerApi(context).metaConfig({
                requestId: context.requestId,
            });
            const cubes = metaConfig
                .map((meta) => meta.config)
                .map((cube) => ({
                ...cube,
                measures: cube.measures.filter(visibilityFilter),
                dimensions: cube.dimensions.filter(visibilityFilter),
            }));
            res({ cubes });
        }
        catch (e) {
            this.handleError({
                e,
                context,
                res,
                requestStarted,
            });
        }
    }
    async metaExtended({ context, res }) {
        const requestStarted = new Date();
        function visibilityFilter(item) {
            return shared_1.getEnv('devMode') || context.signedWithPlaygroundAuthSecret || item.isVisible;
        }
        try {
            const metaConfigExtended = await this.getCompilerApi(context).metaConfigExtended({
                requestId: context.requestId,
            });
            const { metaConfig, cubeDefinitions } = metaConfigExtended;
            const cubes = metaConfig
                .map((meta) => meta.config)
                .map((cube) => {
                var _a, _b, _c, _d, _e;
                return ({
                    ...transformMetaExtended_1.transformCube(cube, cubeDefinitions),
                    measures: (_a = cube.measures) === null || _a === void 0 ? void 0 : _a.filter(visibilityFilter).map((measure) => ({
                        ...transformMetaExtended_1.transformMeasure(measure, cubeDefinitions),
                    })),
                    dimensions: (_b = cube.dimensions) === null || _b === void 0 ? void 0 : _b.filter(visibilityFilter).map((dimension) => ({
                        ...transformMetaExtended_1.transformDimension(dimension, cubeDefinitions),
                    })),
                    segments: (_c = cube.segments) === null || _c === void 0 ? void 0 : _c.map((segment) => ({
                        ...transformMetaExtended_1.transformSegment(segment, cubeDefinitions),
                    })),
                    joins: transformMetaExtended_1.transformJoins((_d = cubeDefinitions[cube.name]) === null || _d === void 0 ? void 0 : _d.joins),
                    preAggregations: transformMetaExtended_1.transformPreAggregations((_e = cubeDefinitions[cube.name]) === null || _e === void 0 ? void 0 : _e.preAggregations),
                });
            });
            res({ cubes });
        }
        catch (e) {
            this.handleError({
                e,
                context,
                res,
                requestStarted,
            });
        }
    }
    async getPreAggregations({ cacheOnly, context, res }) {
        const requestStarted = new Date();
        try {
            const compilerApi = this.getCompilerApi(context);
            const preAggregations = await compilerApi.preAggregations();
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, query_1.normalizeQueryPreAggregations({
                timezones: this.scheduledRefreshTimeZones,
                preAggregations: preAggregations.map(p => ({
                    id: p.id,
                    cacheOnly,
                }))
            }));
            res({ preAggregations: preAggregationPartitions.map(({ preAggregation }) => preAggregation) });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async getPreAggregationPartitions({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = query_1.normalizeQueryPreAggregations(this.parseQueryParam(query), { timezones: this.scheduledRefreshTimeZones });
            const orchestratorApi = this.getAdapterApi(context);
            const compilerApi = this.getCompilerApi(context);
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, query);
            const preAggregationPartitionsWithoutError = preAggregationPartitions.filter(p => { var _a; return !((_a = p === null || p === void 0 ? void 0 : p.errors) === null || _a === void 0 ? void 0 : _a.length); });
            const versionEntriesResult = preAggregationPartitions &&
                await orchestratorApi.getPreAggregationVersionEntries(context, preAggregationPartitionsWithoutError, compilerApi.preAggregationsSchema);
            const mergePartitionsAndVersionEntries = () => ({ preAggregation, partitions, ...props }) => ({
                ...props,
                preAggregation,
                partitions: partitions.map(partition => {
                    partition.versionEntries = (versionEntriesResult === null || versionEntriesResult === void 0 ? void 0 : versionEntriesResult.versionEntriesByTableName[partition === null || partition === void 0 ? void 0 : partition.tableName]) || [];
                    partition.structureVersion = versionEntriesResult === null || versionEntriesResult === void 0 ? void 0 : versionEntriesResult.structureVersionsByTableName[partition === null || partition === void 0 ? void 0 : partition.tableName];
                    return partition;
                }),
            });
            res({
                preAggregationPartitions: preAggregationPartitions.map(mergePartitionsAndVersionEntries())
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async getPreAggregationPreview({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = query_1.normalizeQueryPreAggregationPreview(this.parseQueryParam(query));
            const { preAggregationId, versionEntry, timezone } = query;
            const orchestratorApi = this.getAdapterApi(context);
            const preAggregationPartitions = await this.refreshScheduler()
                .preAggregationPartitions(context, {
                timezones: [timezone],
                preAggregations: [{ id: preAggregationId }]
            });
            const { partitions } = (preAggregationPartitions && preAggregationPartitions[0] || {});
            const preAggregationPartition = partitions && partitions.find(p => (p === null || p === void 0 ? void 0 : p.tableName) === versionEntry.table_name);
            res({
                preview: preAggregationPartition && await orchestratorApi.getPreAggregationPreview(context, preAggregationPartition)
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async buildPreAggregations({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = query_1.normalizeQueryPreAggregations(this.parseQueryParam(query));
            const result = await this.refreshScheduler()
                .buildPreAggregations(context, query);
            res({ result });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async getPreAggregationsInQueue({ context, res }) {
        const requestStarted = new Date();
        try {
            const orchestratorApi = this.getAdapterApi(context);
            res({
                result: await orchestratorApi.getPreAggregationQueueStates()
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    async cancelPreAggregationsFromQueue({ query, context, res }) {
        const requestStarted = new Date();
        try {
            const { queryKeys, dataSource } = query_1.normalizeQueryCancelPreAggregations(this.parseQueryParam(query));
            const orchestratorApi = this.getAdapterApi(context);
            res({
                result: await orchestratorApi.cancelPreAggregationQueriesFromQueue(queryKeys, dataSource)
            });
        }
        catch (e) {
            this.handleError({
                e, context, res, requestStarted
            });
        }
    }
    /**
     * Convert incoming query parameter (JSON fetched from the HTTP) to
     * an array of query type and array of normalized queries.
     */
    async getNormalizedQueries(query, context) {
        query = this.parseQueryParam(query);
        let queryType = enums_1.QueryType.REGULAR_QUERY;
        if (!Array.isArray(query)) {
            query = this.compareDateRangeTransformer(query);
            if (Array.isArray(query)) {
                queryType = enums_1.QueryType.COMPARE_DATE_RANGE_QUERY;
            }
        }
        else {
            queryType = enums_1.QueryType.BLENDING_QUERY;
        }
        const queries = Array.isArray(query) ? query : [query];
        const normalizedQueries = await Promise.all(queries.map(async (currentQuery) => query_1.validatePostRewrite(await this.queryRewrite(query_1.normalizeQuery(currentQuery), context))));
        if (normalizedQueries.find((currentQuery) => !currentQuery)) {
            throw new Error('queryTransformer returned null query. Please check your queryTransformer implementation');
        }
        if (queryType === enums_1.QueryType.BLENDING_QUERY) {
            const queryGranularity = query_1.getQueryGranularity(normalizedQueries);
            if (queryGranularity.length > 1) {
                throw new UserError_1.UserError('Data blending query granularities must match');
            }
            if (queryGranularity.filter(Boolean).length === 0) {
                throw new UserError_1.UserError('Data blending query without granularity is not supported');
            }
        }
        return [queryType, normalizedQueries];
    }
    async sql({ query, context, res }) {
        const requestStarted = new Date();
        try {
            query = this.parseQueryParam(query);
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);
            const sqlQueries = await Promise.all(normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(this.coerceForSqlQuery(normalizedQuery, context), { includeDebugInfo: shared_1.getEnv('devMode') || context.signedWithPlaygroundAuthSecret })));
            const toQuery = (sqlQuery) => ({
                ...sqlQuery,
                order: ramda_1.default.fromPairs(sqlQuery.order.map(({ id: key, desc }) => [key, desc ? 'desc' : 'asc']))
            });
            res(queryType === enums_1.QueryType.REGULAR_QUERY ?
                { sql: toQuery(sqlQueries[0]) } :
                sqlQueries.map((sqlQuery) => ({ sql: toQuery(sqlQuery) })));
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    createSecurityContextExtractor(options) {
        if (options === null || options === void 0 ? void 0 : options.claimsNamespace) {
            return (ctx) => {
                if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {
                    if (options.claimsNamespace in ctx.securityContext) {
                        return ctx.securityContext[options.claimsNamespace];
                    }
                }
                return {};
            };
        }
        let checkAuthDeprecationShown = false;
        return (ctx) => {
            let securityContext = {};
            if (typeof ctx.securityContext === 'object' && ctx.securityContext !== null) {
                if (ctx.securityContext.u) {
                    if (!checkAuthDeprecationShown) {
                        this.logger('JWT U Property Deprecation', {
                            warning: ('Storing security context in the u property within the payload is now deprecated, please migrate: ' +
                                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#authinfo')
                        });
                        checkAuthDeprecationShown = true;
                    }
                    securityContext = {
                        ...ctx.securityContext,
                        ...ctx.securityContext.u,
                    };
                    delete securityContext.u;
                }
                else {
                    securityContext = ctx.securityContext;
                }
            }
            return securityContext;
        };
    }
    coerceForSqlQuery(query, context) {
        return {
            ...query,
            timeDimensions: query.timeDimensions || [],
            contextSymbols: {
                securityContext: this.securityContextExtractor(context),
            },
            requestId: context.requestId
        };
    }
    async dryRun({ query, context, res }) {
        const requestStarted = new Date();
        try {
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);
            const sqlQueries = await Promise.all(normalizedQueries.map((normalizedQuery) => this.getCompilerApi(context).getSql(this.coerceForSqlQuery(normalizedQuery, context), {
                includeDebugInfo: shared_1.getEnv('devMode') || context.signedWithPlaygroundAuthSecret
            })));
            res({
                queryType,
                normalizedQueries,
                queryOrder: sqlQueries.map((sqlQuery) => ramda_1.default.fromPairs(sqlQuery.order.map(({ id: member, desc }) => [member, desc ? 'desc' : 'asc']))),
                transformedQueries: sqlQueries.map((sqlQuery) => sqlQuery.canUseTransformedQuery),
                pivotQuery: query_1.getPivotQuery(queryType, normalizedQueries)
            });
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    /**
     * Returns an array of sqlQuery objects for specified normalized
     * queries.
     * @internal
     */
    async getSqlQueriesInternal(context, normalizedQueries) {
        const sqlQueries = await Promise.all(normalizedQueries.map(async (normalizedQuery, index) => {
            const loadRequestSQLStarted = new Date();
            const sqlQuery = await this.getCompilerApi(context)
                .getSql(this.coerceForSqlQuery(normalizedQuery, context));
            this.log({
                type: 'Load Request SQL',
                duration: this.duration(loadRequestSQLStarted),
                query: normalizedQueries[index],
                sqlQuery
            }, context);
            return sqlQuery;
        }));
        return sqlQueries;
    }
    /**
     * Execute query and return adapter's result.
     * @internal
     */
    async getSqlResponseInternal(context, normalizedQuery, sqlQuery) {
        const queries = [{
                ...sqlQuery,
                query: sqlQuery.sql[0],
                values: sqlQuery.sql[1],
                continueWait: true,
                renewQuery: normalizedQuery.renewQuery,
                requestId: context.requestId,
                context
            }];
        if (normalizedQuery.total) {
            const normalizedTotal = structured_clone_1.default(normalizedQuery);
            normalizedTotal.totalQuery = true;
            normalizedTotal.limit = null;
            normalizedTotal.rowLimit = null;
            normalizedTotal.offset = null;
            const [totalQuery] = await this.getSqlQueriesInternal(context, [normalizedTotal]);
            queries.push({
                ...totalQuery,
                query: totalQuery.sql[0],
                values: totalQuery.sql[1],
                continueWait: true,
                renewQuery: normalizedTotal.renewQuery,
                requestId: context.requestId,
                context
            });
        }
        const [response, total] = await Promise.all(queries.map(async (query) => {
            const res = await this
                .getAdapterApi(context)
                .executeQuery(query);
            return res;
        }));
        response.total = normalizedQuery.total
            ? Number(total.data[0][shared_1.QueryAlias.TOTAL_COUNT])
            : undefined;
        return response;
    }
    /**
     * Convert adapter's result and other request paramters to a final
     * result object.
     * @internal
     */
    getResultInternal(context, queryType, normalizedQuery, sqlQuery, annotation, response, responseType) {
        var _a;
        return {
            query: normalizedQuery,
            data: transformData_1.default(sqlQuery.aliasNameToMember, {
                ...annotation.measures,
                ...annotation.dimensions,
                ...annotation.timeDimensions
            }, response.data, normalizedQuery, queryType, responseType),
            lastRefreshTime: (_a = response.lastRefreshTime) === null || _a === void 0 ? void 0 : _a.toISOString(),
            ...(shared_1.getEnv('devMode') ||
                context.signedWithPlaygroundAuthSecret
                ? {
                    refreshKeyValues: response.refreshKeyValues,
                    usedPreAggregations: response.usedPreAggregations,
                    transformedQuery: sqlQuery.canUseTransformedQuery,
                    requestId: context.requestId,
                }
                : null),
            annotation,
            dataSource: response.dataSource,
            dbType: response.dbType,
            extDbType: response.extDbType,
            external: response.external,
            slowQuery: Boolean(response.slowQuery),
            total: normalizedQuery.total ? response.total : null,
        };
    }
    /**
     * Data queries APIs (`/load`, `/subscribe`) entry point. Used by
     * `CubejsApi#load` and `CubejsApi#subscribe` methods to fetch the
     * data.
     */
    async load(request) {
        let query;
        const { context, res, apiType = 'rest', ...props } = request;
        const requestStarted = new Date();
        try {
            query = this.parseQueryParam(request.query);
            let resType = enums_1.ResultType.DEFAULT;
            if (!Array.isArray(query) && query.responseFormat) {
                resType = query.responseFormat;
            }
            this.log({
                type: 'Load Request',
                query
            }, context);
            const [queryType, normalizedQueries] = await this.getNormalizedQueries(query, context);
            const metaConfigResult = await this
                .getCompilerApi(context).metaConfig({
                requestId: context.requestId
            });
            const sqlQueries = await this
                .getSqlQueriesInternal(context, normalizedQueries);
            let slowQuery = false;
            const results = await Promise.all(normalizedQueries.map(async (normalizedQuery, index) => {
                slowQuery = slowQuery ||
                    Boolean(sqlQueries[index].slowQuery);
                const annotation = prepareAnnotation_1.prepareAnnotation(metaConfigResult, normalizedQuery);
                const response = await this.getSqlResponseInternal(context, normalizedQuery, sqlQueries[index]);
                return this.getResultInternal(context, queryType, normalizedQuery, sqlQueries[index], annotation, response, resType);
            }));
            this.log({
                type: 'Load Request Success',
                query,
                duration: this.duration(requestStarted),
                apiType,
                isPlayground: Boolean(context.signedWithPlaygroundAuthSecret),
                queries: results.length,
                queriesWithPreAggregations: results.filter((r) => Object.keys(r.usedPreAggregations || {}).length).length,
                queriesWithData: results.filter((r) => { var _a; return (_a = r.data) === null || _a === void 0 ? void 0 : _a.length; }).length,
                dbType: results.map(r => r.dbType),
            }, context);
            if (queryType !== enums_1.QueryType.REGULAR_QUERY &&
                props.queryType == null) {
                throw new UserError_1.UserError(`'${queryType}' query type is not supported by the client.` +
                    'Please update the client.');
            }
            if (props.queryType === 'multi') {
                res({
                    queryType,
                    results,
                    pivotQuery: query_1.getPivotQuery(queryType, normalizedQueries),
                    slowQuery
                });
            }
            else {
                res(results[0]);
            }
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }) {
        if (this.enforceSecurityChecks && !signedWithPlaygroundAuthSecret) {
            throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Only for signed with playground auth secret');
        }
        return this.getAdapterApi(context).subscribeQueueEvents(connectionId, res);
    }
    unSubscribeQueueEvents({ context, connectionId }) {
        return this.getAdapterApi(context).unSubscribeQueueEvents(connectionId);
    }
    async subscribe({ query, context, res, subscribe, subscriptionState, queryType, apiType }) {
        const requestStarted = new Date();
        try {
            this.log({
                type: 'Subscribe',
                query
            }, context);
            let result = null;
            let error = null;
            if (!subscribe) {
                await this.load({ query, context, res, queryType, apiType });
                return;
            }
            // TODO subscribe to refreshKeys instead of constantly firing load
            await this.load({
                query,
                context,
                res: (message, opts) => {
                    if (!Array.isArray(message) && message.error) {
                        error = { message, opts };
                    }
                    else {
                        result = { message, opts };
                    }
                },
                queryType,
                apiType,
            });
            const state = await subscriptionState();
            if (result && (!state || JSON.stringify(state.result) !== JSON.stringify(result))) {
                res(result.message, result.opts);
            }
            else if (error) {
                res(error.message, error.opts);
            }
            await subscribe({ error, result });
        }
        catch (e) {
            this.handleError({
                e, context, query, res, requestStarted
            });
        }
    }
    resToResultFn(res) {
        return (message, { status } = {}) => (status ? res.status(status).json(message) : res.json(message));
    }
    parseQueryParam(query) {
        if (!query || query === 'undefined') {
            throw new UserError_1.UserError('query param is required');
        }
        if (typeof query === 'string') {
            query = JSON.parse(query);
        }
        return query;
    }
    getCompilerApi(context) {
        if (typeof this.compilerApi === 'function') {
            return this.compilerApi(context);
        }
        return this.compilerApi;
    }
    getAdapterApi(context) {
        if (typeof this.adapterApi === 'function') {
            return this.adapterApi(context);
        }
        return this.adapterApi;
    }
    async contextByReq(req, securityContext, requestId) {
        const extensions = typeof this.extendContext === 'function' ? await this.extendContext(req) : {};
        return {
            securityContext,
            // Deprecated, but let's allow it for now.
            authInfo: securityContext,
            signedWithPlaygroundAuthSecret: Boolean(req.signedWithPlaygroundAuthSecret),
            requestId,
            ...extensions,
        };
    }
    handleError({ e, context, query, res, requestStarted }) {
        const { requestId } = context;
        if (e instanceof CubejsHandlerError_1.CubejsHandlerError) {
            this.log({
                type: e.type,
                query,
                error: e.message,
                duration: this.duration(requestStarted)
            }, context);
            res({ error: e.message, stack: e.stack, requestId }, { status: e.status });
        }
        else if (e.error === 'Continue wait') {
            this.log({
                type: 'Continue wait',
                query,
                error: e.message,
                duration: this.duration(requestStarted)
            }, context);
            res(e, { status: 200 });
        }
        else if (e.error) {
            this.log({
                type: 'Orchestrator error',
                query,
                error: e.error,
                duration: this.duration(requestStarted),
            }, context);
            res(e, { status: 400 });
        }
        else if (e.type === 'UserError') {
            this.log({
                type: e.type,
                query,
                error: e.message,
                duration: this.duration(requestStarted)
            }, context);
            res({
                type: e.type,
                error: e.message,
                stack: e.stack,
                requestId
            }, { status: 400 });
        }
        else {
            this.log({
                type: 'Internal Server Error',
                query,
                error: e.stack || e.toString(),
                duration: this.duration(requestStarted)
            }, context);
            res({ error: e.toString(), stack: e.stack, requestId }, { status: 500 });
        }
    }
    wrapCheckAuthMiddleware(fn) {
        this.logger('CheckAuthMiddleware Middleware Deprecation', {
            warning: ('Option checkAuthMiddleware is now deprecated in favor of checkAuth, please migrate: ' +
                'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware')
        });
        let showWarningAboutNotObject = false;
        return (req, res, next) => {
            fn(req, res, (e) => {
                // We renamed authInfo to securityContext, but users can continue to use both ways
                if (req.securityContext && !req.authInfo) {
                    req.authInfo = req.securityContext;
                }
                else if (req.authInfo) {
                    req.securityContext = req.authInfo;
                }
                if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {
                    this.logger('Security Context Should Be Object', {
                        warning: (`Value of securityContext (previously authInfo) expected to be object, actual: ${shared_1.getRealType(req.securityContext)}`)
                    });
                    showWarningAboutNotObject = true;
                }
                next(e);
            });
        };
    }
    wrapCheckAuth(fn) {
        // We dont need to span all logs with deprecation message
        let warningShowed = false;
        // securityContext should be object
        let showWarningAboutNotObject = false;
        return async (req, auth) => {
            await fn(req, auth);
            // We renamed authInfo to securityContext, but users can continue to use both ways
            if (req.securityContext && !req.authInfo) {
                req.authInfo = req.securityContext;
            }
            else if (req.authInfo) {
                if (!warningShowed) {
                    this.logger('AuthInfo Deprecation', {
                        warning: ('authInfo was renamed to securityContext, please migrate: ' +
                            'https://github.com/cube-js/cube.js/blob/master/DEPRECATION.md#checkauthmiddleware')
                    });
                    warningShowed = true;
                }
                req.securityContext = req.authInfo;
            }
            if ((typeof req.securityContext !== 'object' || req.securityContext === null) && !showWarningAboutNotObject) {
                this.logger('Security Context Should Be Object', {
                    warning: (`Value of securityContext (previously authInfo) expected to be object, actual: ${shared_1.getRealType(req.securityContext)}`)
                });
                showWarningAboutNotObject = true;
            }
        };
    }
    createDefaultCheckAuth(options, internalOptions) {
        const verifyToken = (auth, secret) => jsonwebtoken_1.default.verify(auth, secret, {
            algorithms: options === null || options === void 0 ? void 0 : options.algorithms,
            issuer: options === null || options === void 0 ? void 0 : options.issuer,
            audience: options === null || options === void 0 ? void 0 : options.audience,
            subject: options === null || options === void 0 ? void 0 : options.subject,
        });
        let checkAuthFn = verifyToken;
        if (options === null || options === void 0 ? void 0 : options.jwkUrl) {
            const jwks = jwk_1.createJWKsFetcher(options, {
                onBackgroundException: (e) => {
                    this.logger('JWKs Background Fetching Error', {
                        error: e.message,
                    });
                },
            });
            this.releaseListeners.push(jwks.release);
            // Precache JWKs response to speedup first auth
            if (options.jwkUrl && typeof options.jwkUrl === 'string') {
                jwks.fetchOnly(options.jwkUrl).catch((e) => this.logger('JWKs Prefetching Error', {
                    error: e.message,
                }));
            }
            checkAuthFn = async (auth) => {
                const decoded = jsonwebtoken_1.default.decode(auth, { complete: true });
                if (!decoded) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Unable to decode JWT key');
                }
                if (!decoded.header || !decoded.header.kid) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'JWT without kid inside headers');
                }
                const jwk = await jwks.getJWKbyKid(typeof options.jwkUrl === 'function' ? options.jwkUrl(decoded) : options.jwkUrl, decoded.header.kid);
                if (!jwk) {
                    throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', `Unable to verify, JWK with kid: "${decoded.header.kid}" not found`);
                }
                return verifyToken(auth, jwk);
            };
        }
        const secret = (options === null || options === void 0 ? void 0 : options.key) || this.apiSecret;
        return async (req, auth) => {
            if (auth) {
                try {
                    req.securityContext = await checkAuthFn(auth, secret);
                    req.signedWithPlaygroundAuthSecret = Boolean(internalOptions === null || internalOptions === void 0 ? void 0 : internalOptions.isPlaygroundCheckAuth);
                }
                catch (e) {
                    if (this.enforceSecurityChecks) {
                        throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Invalid token');
                    }
                    else {
                        this.log({
                            type: e.message,
                            token: auth,
                            error: e.stack || e.toString()
                        }, req);
                    }
                }
            }
            else if (this.enforceSecurityChecks) {
                // @todo Move it to 401 or 400
                throw new CubejsHandlerError_1.CubejsHandlerError(403, 'Forbidden', 'Authorization header isn\'t set');
            }
        };
    }
    createCheckAuthFn(options) {
        const mainCheckAuthFn = options.checkAuth
            ? this.wrapCheckAuth(options.checkAuth)
            : this.createDefaultCheckAuth(options.jwt);
        if (this.playgroundAuthSecret) {
            const systemCheckAuthFn = this.createCheckAuthSystemFn();
            return async (ctx, authorization) => {
                try {
                    await mainCheckAuthFn(ctx, authorization);
                }
                catch (error) {
                    await systemCheckAuthFn(ctx, authorization);
                }
            };
        }
        return (ctx, authorization) => mainCheckAuthFn(ctx, authorization);
    }
    createCheckAuthSystemFn() {
        const systemCheckAuthFn = this.createDefaultCheckAuth({
            key: this.playgroundAuthSecret,
            algorithms: ['HS256']
        }, { isPlaygroundCheckAuth: true });
        return async (ctx, authorization) => {
            await systemCheckAuthFn(ctx, authorization);
        };
    }
    extractAuthorizationHeaderWithSchema(req) {
        if (typeof req.headers.authorization === 'string') {
            const parts = req.headers.authorization.split(' ', 2);
            if (parts.length === 1) {
                return parts[0];
            }
            return parts[1];
        }
        return undefined;
    }
    async checkAuthWrapper(checkAuthFn, req, res, next) {
        const token = this.extractAuthorizationHeaderWithSchema(req);
        try {
            await checkAuthFn(req, token);
            if (next) {
                next();
            }
        }
        catch (e) {
            if (e instanceof CubejsHandlerError_1.CubejsHandlerError) {
                res.status(e.status).json({ error: e.message });
            }
            else if (e instanceof Error) {
                this.log({
                    type: 'Auth Error',
                    token,
                    error: e.stack || e.toString()
                }, req);
                res.status(500).json({
                    error: e.toString(),
                    stack: e.stack
                });
            }
        }
    }
    compareDateRangeTransformer(query) {
        let queryCompareDateRange;
        let compareDateRangeTDIndex;
        (query.timeDimensions || []).forEach((td, index) => {
            if (td.compareDateRange != null) {
                if (queryCompareDateRange != null) {
                    throw new UserError_1.UserError('compareDateRange can only exist for one timeDimension');
                }
                queryCompareDateRange = td.compareDateRange;
                compareDateRangeTDIndex = index;
            }
        });
        if (queryCompareDateRange == null) {
            return query;
        }
        return queryCompareDateRange.map((dateRange) => ({
            ...ramda_1.default.clone(query),
            timeDimensions: query.timeDimensions.map((td, index) => {
                if (compareDateRangeTDIndex === index) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    const { compareDateRange, ...timeDimension } = td;
                    return {
                        ...timeDimension,
                        dateRange
                    };
                }
                return td;
            })
        }));
    }
    log(event, context) {
        const { type, ...restParams } = event;
        this.logger(type, {
            ...restParams,
            ...(!context ? undefined : {
                securityContext: context.securityContext,
                requestId: context.requestId,
                ...(!context.appName ? undefined : { appName: context.appName }),
                ...(!context.protocol ? undefined : { protocol: context.protocol }),
                ...(!context.apiType ? undefined : { apiType: context.apiType }),
            })
        });
    }
    healthResponse(res, health) {
        res.status(health === 'HEALTH' ? 200 : 500).json({
            health,
        });
    }
    release() {
        for (const releaseListener of this.releaseListeners) {
            releaseListener();
        }
    }
}
exports.ApiGateway = ApiGateway;
//# sourceMappingURL=gateway.js.map